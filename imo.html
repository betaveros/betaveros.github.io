<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>IMO Score Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; font-variant-numeric: tabular-nums; }
        main { max-width: 1000px; margin: 0 auto; }
        h1 { font-weight: normal; margin: 0; }
        aside { font-size: 12px; display: inline; }
        .stats { margin-bottom: 20px; }
        .bar { fill: steelblue; }
        .bar:hover { fill: orange; }
        .axis { font-size: 10px; }
        .medal-gold { fill: #FFCC00; }
        .medal-silver { fill: #CCCCCC; }
        .medal-bronze { fill: #CC9966; }
        .medal-hm { fill: #FF3399; }
        .medal-none { fill: #99CCFF; }

        table { border-collapse: collapse; width: 100%; }
        th, td { padding: 0 3px; text-align: center; font-size: 12px; }
        th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 10; }
        .compact-col { width: 10px; }
        .loading { text-align: center; padding: 20px; }
        .small-percent { font-size: 8px; }
        .stat-cell { text-align: right; }
        .bg-gold { background-color: #FFCC00; }
        .bg-silver { background-color: #CCCCCC; }
        .bg-bronze { background-color: #CC9966; }
        .bg-hm { background-color: #FF3399; color: white; }
        .bg-hm.disabled { opacity: 0.3; }
        .bg-none { background-color: #99CCFF; }
        .sortable { cursor: pointer; user-select: none; }
        .sortable:hover { background-color: #e6e6e6; }
        .problem-sortable { cursor: pointer; user-select: none; }
        .problem-sortable:hover { background-color: #e6e6e6; }
        .problem-table-narrow { width: 60px; text-align: center; }
        .problem-table-chart { text-align: center; }
        .sort-indicator {
            position: absolute;
            opacity: 0.5;
            top: 0;
            right: 2px;
            font-size: 8px;
            line-height: 1;
        }
        .chart-toggle {
            font-size: 10px;
            margin-bottom: 5px;
            text-align: center;
        }
        .chart-toggle input[type="checkbox"] {
            margin-right: 3px;
        }
    </style>
</head>
<body>
<main>
    <h1>IMO Statistics <aside>betaveros (with heavy Claude assistance)</aside></h1>

    <div class="loading" id="loading">Loading data...</div>

    <div id="scatterplot" style="display: none; margin-bottom: 20px; text-align: center"></div>

    <div id="problem-scores-scatterplot" style="display: none; margin-bottom: 20px; text-align: center"></div>

    <div id="bee-swarm-plot" style="display: none; margin-bottom: 20px; text-align: center"></div>

    <table id="stats-table" style="display: none; margin-top: 10px">
        <thead>
            <tr>
                <th class="compact-col sortable" title="Year" data-column="year">Year<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Number of Contestants" data-column="total">#<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Gold Medal Percentage" data-column="goldPct">G%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Silver Medal Percentage" data-column="silverPct">≥S%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Bronze Medal Percentage" data-column="bronzePct">≥B%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Honourable Mention Percentage" data-column="hmPct">HM%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="No Award Percentage" data-column="nonePct">N%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Gold Medal Cutoff Score" data-column="goldCutoff">G<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Silver Medal Cutoff Score" data-column="silverCutoff">S<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Bronze Medal Cutoff Score" data-column="bronzeCutoff">B<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Mean Score" data-column="mean">μ<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Median Score" data-column="median"><small>Med</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Mode (Most Common Score)" data-column="mode"><small>Mode</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Standard Deviation" data-column="stdDev">σ<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Minimum Score" data-column="min"><small>Min</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Maximum Score" data-column="max"><small>Max</small><span class="sort-indicator"></span></th>
                <th class="chart-cell" title="Score Distribution by Medal Type">
                    Score Distribution
                    <label class="chart-toggle"><input type="checkbox" id="stackedToggle" onchange="toggleChartType()"> Stacked</label>
                </th>
            </tr>
        </thead>
        <tbody id="stats-body">
        </tbody>
    </table>

    <table id="problem-stats-table" style="display: none; margin-top: 20px">
        <thead>
            <tr>
                <th colspan="4" style="text-align: center; padding: 10px; font-size: 14px; position: static">
                    Individual Problem Statistics (1982+)
                </th>
            </tr>
            <tr>
                <th class="problem-sortable problem-table-narrow" data-column="year">Year<span class="sort-indicator"></span></th>
                <th class="problem-sortable problem-table-narrow" data-column="problem">Prob.<span class="sort-indicator"></span></th>
                <th class="problem-sortable problem-table-narrow" data-column="averageScore">Avg Score<span class="sort-indicator"></span></th>
                <th class="problem-table-chart">
                    Score Distribution<span class="sort-indicator"></span>
                    <label class="chart-toggle">
                        <input type="checkbox" id="problemStackedToggle"> Stacked bars
                    </label>
                </th>
            </tr>
        </thead>
        <tbody id="problem-stats-body">
        </tbody>
    </table>

    <script>
        // Color scheme
        const COLORS = {
            gold: '#FFCC00',
            silver: '#CCCCCC',
            bronze: '#CC9966',
            hm: '#FF3399',
            none: '#99CCFF',
            goldCutoff: '#806100',
            silverCutoff: '#666666',
            bronzeCutoff: '#885c2c',
            gridLine: '#aaa',
            yearLine: '#ccc',
            yearLineHighlight: '#333'
        };

        // Load data from JSON file
        fetch('imo.json')
            .then(response => response.json())
            .then(allYearData => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('scatterplot').style.display = 'block';
                document.getElementById('problem-scores-scatterplot').style.display = 'block';
                document.getElementById('bee-swarm-plot').style.display = 'block';
                document.getElementById('problem-stats-table').style.display = 'table';
                document.getElementById('stats-table').style.display = 'table';
                processAllYears(allYearData);
            })
            .catch(error => {
                document.getElementById('loading').innerHTML = 'Error loading data: ' + error;
            });

        function parseMedal(medal) {
            if (medal === "Special prize") return "None";
            let c = medal.indexOf(",");
            if (c >= 0) medal = medal.slice(0, c);
            return medal || "None";
        }

        // Process data for a single year
        function processYearData(data) {
            return data.map(d => ({
                id: d[0],
                scores: d[1],
                total: d[1].reduce((a, b) => a + b, 0),
                medal: parseMedal(d[2])
            }));
        }

        // Calculate statistics for a year
        function calculateStats(processedData) {
            const total = processedData.length;
            const scores = processedData.map(d => d.total);

            // Medal counts
            const gold = processedData.filter(d => d.medal === 'Gold medal').length;
            const silver = processedData.filter(d => d.medal === 'Silver medal').length;
            const bronze = processedData.filter(d => d.medal === 'Bronze medal').length;
            const hm = processedData.filter(d => d.medal === 'Honourable mention').length;
            const none = processedData.filter(d => d.medal === 'None' || d.medal === '').length;

            // Medal cutoffs (minimum scores for each medal type)
            const goldScores = processedData.filter(d => d.medal === 'Gold medal').map(d => d.total);
            const silverScores = processedData.filter(d => d.medal === 'Silver medal').map(d => d.total);
            const bronzeScores = processedData.filter(d => d.medal === 'Bronze medal').map(d => d.total);

            const goldCutoff = goldScores.length > 0 ? Math.min(...goldScores) : null;
            const silverCutoff = silverScores.length > 0 ? Math.min(...silverScores) : null;
            const bronzeCutoff = bronzeScores.length > 0 ? Math.min(...bronzeScores) : null;

            // Basic stats
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const sortedScores = [...scores].sort((a, b) => a - b);
            const median = sortedScores.length % 2 === 0
                ? (sortedScores[sortedScores.length/2 - 1] + sortedScores[sortedScores.length/2]) / 2
                : sortedScores[Math.floor(sortedScores.length/2)];

            // Mode (most common score)
            const scoreFreq = {};
            scores.forEach(s => scoreFreq[s] = (scoreFreq[s] || 0) + 1);
            const mode = Object.keys(scoreFreq).reduce((a, b) => scoreFreq[a] > scoreFreq[b] ? a : b);

            // Standard deviation
            const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
            const stdDev = Math.sqrt(variance);

            const min = Math.min(...scores);
            const max = Math.max(...scores);

            return {
                total,
                gold, silver, bronze, hm, none,
                goldPct: gold/total,
                silverPct: (gold+silver)/total,
                bronzePct: (gold+silver+bronze)/total,
                hmPct: hm/total,
                nonePct: none/total,
                goldCutoff, silverCutoff, bronzeCutoff,
                mean,
                median,
                mode,
                stdDev,
                min, max
            };
        }

        // Create histogram data for a year
        function createHistogramData(processedData, year) {
            const scoreGroups = d3.group(processedData, d => d.total);
            const histogramData = [];
            const maxScore = getMaxScore(year);

            for (let score = 0; score <= maxScore; score++) {
                const contestants = scoreGroups.get(score) || [];
                const medalGroups = d3.group(contestants, d => d.medal);

                const medalData = {
                    'Gold medal': medalGroups.get('Gold medal')?.length || 0,
                    'Silver medal': medalGroups.get('Silver medal')?.length || 0,
                    'Bronze medal': medalGroups.get('Bronze medal')?.length || 0,
                    'Honourable mention': medalGroups.get('Honourable mention')?.length || 0,
                    'None': medalGroups.get('None')?.length || 0,
                };

                let eq = medalData['Gold medal'] +
                 medalData['Silver medal'] +
                 medalData['Bronze medal'] +
                 medalData['Honourable mention'] +
                 medalData['None'] === contestants.length;
                if (!eq) console.warn(medalGroups);

                histogramData.push({
                    score: score,
                    count: contestants.length,
                    medals: medalData
                });
            }

            return histogramData;
        }

        // Get maximum possible score for a given year
        function getMaxScore(year) {
            if (year >= 1980) return 42;
            if (year === 1971 || year === 1967 || year === 1964) return 42;
            if (year === 1962) return 46;
            if (year === 1960) return 44;
            return 40;
        }

        // Create mini bar chart for table cell
        function createMiniChart(histogramData, cellId, stats, year) {
            const margin = {top: 5, right: 5, bottom: 13, left: 25};
            const width = 480 - margin.left - margin.right;
            const height = 75 - margin.top - margin.bottom;

            const svg = d3.select(`#${cellId}`)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Show full score range for the year (0 to max possible)
            const maxScore = getMaxScore(year);
            const allScores = Array.from({length: maxScore + 1}, (_, i) => i);

            const x = d3.scaleBand()
                .domain(allScores)
                .range([0, width])
                .padding(0.1);

            const maxCount = d3.max(histogramData, d => d.count);
            const y = d3.scaleLinear()
                .domain([0, maxCount])
                .range([height, 0]);

            // Create stacked data
            const medalTypes = ['Gold medal', 'Silver medal', 'Bronze medal', 'Honourable mention', 'None'];
            const stackedData = [];

            histogramData.forEach(d => {
                let y0 = 0;
                medalTypes.forEach(medalType => {
                    const count = d.medals[medalType];
                    if (count > 0) {
                        stackedData.push({
                            score: d.score,
                            medalType: medalType,
                            count: count,
                            y0: y0,
                            y1: y0 + count
                        });
                    }
                    y0 += count;
                });
            });

            // Add dashed vertical lines for cutoffs (behind bars)
            const cutoffData = [
                { score: stats.goldCutoff, color: COLORS.goldCutoff },
                { score: stats.silverCutoff, color: COLORS.silverCutoff },
                { score: stats.bronzeCutoff, color: COLORS.bronzeCutoff }
            ].filter(d => d.score !== null);

            cutoffData.forEach(({ score, color }) => {
                g.append("line")
                    .attr("x1", x(score))
                    .attr("x2", x(score))
                    .attr("y1", -5)
                    .attr("y2", height)
                    .attr("stroke", color)
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "2,2")
                    .style("opacity", 0.7);
            });

            // Create bars
            g.selectAll(".bar")
                .data(stackedData)
                .enter().append("rect")
                .attr("class", d => {
                    switch(d.medalType) {
                        case 'Gold medal': return 'bar medal-gold';
                        case 'Silver medal': return 'bar medal-silver';
                        case 'Bronze medal': return 'bar medal-bronze';
                        case 'Honourable mention': return 'bar medal-hm';
                        default: return 'bar medal-none';
                    }
                })
                .attr("x", d => x(d.score))
                .attr("width", x.bandwidth())
                .attr("y", d => y(d.y1))
                .attr("height", d => y(d.y0) - y(d.y1))
                .append("title")
                .text(d => `Score: ${d.score}\n${d.medalType}: ${d.count}`);

            // Generate standard ticks based on year's max score
            const standardTicks = [];
            for (let i = 0; i <= maxScore; i += 7) {
                standardTicks.push(i);
            }
            if (standardTicks[standardTicks.length - 1] !== maxScore) {
                standardTicks.push(maxScore);
            }

            const cutoffTicks = [stats.goldCutoff, stats.silverCutoff, stats.bronzeCutoff].filter(c => c !== null);
            const allTicks = [...new Set([...standardTicks, ...cutoffTicks])].sort((a, b) => a - b);

            const xAxis = g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).tickValues(allTicks).tickSize(0));

            xAxis.selectAll("text")
                .style("fill", d => {
                    if (d == stats.goldCutoff) return COLORS.goldCutoff;
                    if (d == stats.silverCutoff) return COLORS.silverCutoff;
                    if (d == stats.bronzeCutoff) return COLORS.bronzeCutoff;
                    return "#000000";
                })
                .style("font-weight", d => {
                    if (d == stats.goldCutoff || d == stats.silverCutoff || d == stats.bronzeCutoff) return "bold";
                    return "normal";
                });
        }

        function createStackedChart(histogramData, cellId, stats, year) {
            const margin = {top: 0, right: 5, bottom: 15, left: 25};
            const width = 480 - margin.left - margin.right;
            const height = 25 - margin.top - margin.bottom;

            const svg = d3.select(`#${cellId}`)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const totalContestants = histogramData.reduce((sum, d) => sum + d.count, 0);

            // Create segments ordered by score (contestants arranged left to right by their scores)
            const segments = [];
            let runningTotal = 0;

            const maxScore = getMaxScore(year);
            const sortedHistogramData = histogramData
                .filter(d => d.count > 0)
                .sort((a, b) => a.score - b.score);

            sortedHistogramData.forEach(scoreData => {
                // Within each score, order by medal hierarchy
                const medalOrder = ['None', 'Honourable mention', 'Bronze medal', 'Silver medal', 'Gold medal'];

                medalOrder.forEach(medalType => {
                    const count = scoreData.medals[medalType];
                    if (count > 0) {
                        segments.push({
                            score: scoreData.score,
                            medalType: medalType,
                            count: count,
                            x0: runningTotal,
                            x1: runningTotal + count
                        });
                        runningTotal += count;
                    }
                });
            });

            const x = d3.scaleLinear()
                .domain([0, totalContestants])
                .range([0, width]);

            const barHeight = height;
            const barY = (height - barHeight) / 2;

            g.selectAll(".stacked-segment")
                .data(segments)
                .enter().append("rect")
                .attr("class", d => {
                    switch(d.medalType) {
                        case 'Gold medal': return 'stacked-segment medal-gold';
                        case 'Silver medal': return 'stacked-segment medal-silver';
                        case 'Bronze medal': return 'stacked-segment medal-bronze';
                        case 'Honourable mention': return 'stacked-segment medal-hm';
                        default: return 'stacked-segment medal-none';
                    }
                })
                .attr("x", d => x(d.x0))
                .attr("y", barY)
                .attr("width", (d, i) => {
                    return x(d.x1) - x(d.x0);
                })
                .attr("height", barHeight)
                .append("title")
                .text(d => `Score ${d.score}, ${d.medalType}: ${d.count}`);

            const standardTicks = [];
            for (let i = 0; i <= maxScore; i += 7) {
                standardTicks.push(i);
            }
            if (standardTicks[standardTicks.length - 1] !== maxScore) {
                standardTicks.push(maxScore);
            }

            const cutoffTicks = [stats.goldCutoff, stats.silverCutoff, stats.bronzeCutoff].filter(c => c !== null);
            const allTicks = [...new Set([...standardTicks, ...cutoffTicks])].sort((a, b) => a - b);

            // each tick at the START of its score region
            // (actually both ways are awkward since each contestant is "exactly on" a score
            // but this one is more intuitive to me)
            const tickPositions = allTicks.map(score => {
                let cumulative = 0;
                for (let s = 0; s < score; s++) {
                    const scoreData = histogramData.find(d => d.score === s);
                    if (scoreData) {
                        cumulative += scoreData.count;
                    }
                }
                return { score: score, position: cumulative };
            });

            // Add tick marks with overlap prevention
            const minLabelSpacing = 13; // pixels

            // First pass: add all tick lines
            tickPositions.forEach(({ score, position }) => {
                const xPos = x(position);

                // Determine if this is a medal cutoff tick
                const isGoldCutoff = score == stats.goldCutoff;
                const isSilverCutoff = score == stats.silverCutoff;
                const isBronzeCutoff = score == stats.bronzeCutoff;
                const isMedalCutoff = isGoldCutoff || isSilverCutoff || isBronzeCutoff;

                // Set color and width based on tick type
                const tickColor = isGoldCutoff ? COLORS.goldCutoff :
                                 isSilverCutoff ? COLORS.silverCutoff :
                                 isBronzeCutoff ? COLORS.bronzeCutoff : "#000";
                const tickWidth = isMedalCutoff ? 2 : 1;

                // Add tick line
                g.append("line")
                    .attr("x1", xPos)
                    .attr("x2", xPos)
                    .attr("y1", barY)
                    .attr("y2", barY + barHeight + 3)
                    .attr("stroke", tickColor)
                    .attr("stroke-width", tickWidth);
            });

            // Second pass: prevent overlaps right to left by pushing ticks left
            const labelPositions = [];
            [...tickPositions].reverse().forEach(({ score, position }) => {
                const xPos = x(position);
                let adjustedX = xPos;

                for (let existingPos of labelPositions) {
                    if (Math.abs(adjustedX - existingPos) < minLabelSpacing) {
                        // Move to the left of the existing label
                        adjustedX = existingPos - minLabelSpacing;
                    }
                }

                adjustedX = Math.max(adjustedX, 0);

                labelPositions.push(adjustedX);

                // Add tick label at adjusted position
                g.append("text")
                    .attr("x", adjustedX)
                    .attr("y", barY + barHeight + 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .style("fill", score == stats.goldCutoff ? COLORS.goldCutoff :
                                   score == stats.silverCutoff ? COLORS.silverCutoff :
                                   score == stats.bronzeCutoff ? COLORS.bronzeCutoff : "#000000")
                    .style("font-weight", (score == stats.goldCutoff || score == stats.silverCutoff || score == stats.bronzeCutoff) ? "bold" : "normal")
                    .text(score);
            });
        }

        // Toggle between chart types
        function toggleChartType() {
            isStackedView = document.getElementById('stackedToggle').checked;
            renderTable();
        }

        // Global data storage for sorting
        let tableData = [];
        let currentSort = { column: 'year', direction: 'desc' };
        let isStackedView = false;

        // Problem table state
        let problemStats = [];
        let currentProblemSort = { column: 'year', direction: 'desc' };
        let isProblemStackedView = false;

        // Create scatterplot of medal cutoffs
        function createScatterplot(tableData) {
            const margin = {top: 20, right: 20, bottom: 40, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#scatterplot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Filter data for years 1981+ and extract cutoff points
            const cutoffData = [];
            tableData.forEach(({ year, stats, histogramData }) => {
                if (year >= 1981) {
                    const totalContestants = histogramData.reduce((sum, d) => sum + d.count, 0);

                    // Calculate percentile for each cutoff (fraction scoring strictly below cutoff)
                    if (stats.goldCutoff !== null) {
                        let belowGold = 0;
                        histogramData.forEach(d => {
                            if (d.score < stats.goldCutoff) {
                                belowGold += d.count;
                            }
                        });
                        cutoffData.push({
                            year: year,
                            absoluteScore: stats.goldCutoff,
                            percentile: belowGold / totalContestants,
                            medalType: 'Gold'
                        });
                    }

                    if (stats.silverCutoff !== null) {
                        let belowSilver = 0;
                        histogramData.forEach(d => {
                            if (d.score < stats.silverCutoff) {
                                belowSilver += d.count;
                            }
                        });
                        cutoffData.push({
                            year: year,
                            absoluteScore: stats.silverCutoff,
                            percentile: belowSilver / totalContestants,
                            medalType: 'Silver'
                        });
                    }

                    if (stats.bronzeCutoff !== null) {
                        let belowBronze = 0;
                        histogramData.forEach(d => {
                            if (d.score < stats.bronzeCutoff) {
                                belowBronze += d.count;
                            }
                        });
                        cutoffData.push({
                            year: year,
                            absoluteScore: stats.bronzeCutoff,
                            percentile: belowBronze / totalContestants,
                            medalType: 'Bronze'
                        });
                    }
                }
            });

            // Set up scales
            const xScale = d3.scaleLinear()
                .domain([7, 42])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain(d3.extent(cutoffData, d => d.percentile))
                .range([height, 0])
                .nice();

            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickValues([7, 14, 21, 28, 35, 42]))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 35)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Absolute Score");

            g.append("g")
                .call(d3.axisLeft(yScale))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -height / 2)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Percentile");

            // Add vertical grid lines at X-axis ticks
            const xTicks = [7, 14, 21, 28, 35, 42];
            xTicks.forEach(tick => {
                g.append("line")
                    .attr("x1", xScale(tick))
                    .attr("x2", xScale(tick))
                    .attr("y1", 0)
                    .attr("y2", height)
                    .attr("stroke", COLORS.gridLine)
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("stroke-opacity", 0.7);
            });

            // Add ideal cutoff reference lines
            const idealCutoffs = [
                { percentile: 1/2, label: "\u201cIdeal\u201d Bronze", color: COLORS.bronzeCutoff },
                { percentile: 3/4, label: "\u201cIdeal\u201d Silver", color: COLORS.silverCutoff },
                { percentile: 11/12, label: "\u201cIdeal\u201d Gold", color: COLORS.goldCutoff }
            ];

            idealCutoffs.forEach(({ percentile, label, color }) => {
                g.append("line")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", yScale(percentile))
                    .attr("y2", yScale(percentile))
                    .attr("stroke", color)
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("stroke-opacity", 0.7);

                // Add label above the line
                g.append("text")
                    .attr("x", 5)
                    .attr("y", yScale(percentile))
                    .attr("dy", "-0.3em")
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", color)
                    .text(label);
            });

            // Add title
            g.append("text")
                .attr("x", width / 2)
                .attr("y", -5)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Medal Cutoffs: Absolute Score vs Percentile (1981+)");

            // Group data by year for connecting lines
            const yearGroups = d3.group(cutoffData, d => d.year);

            // Add connecting lines for each year
            yearGroups.forEach((yearData, year) => {
                // Sort by medal type order (Bronze -> Silver -> Gold)
                const sortedData = yearData.sort((a, b) => {
                    const order = { 'Bronze': 0, 'Silver': 1, 'Gold': 2 };
                    return order[a.medalType] - order[b.medalType];
                });

                if (sortedData.length > 1) {
                    const lineGenerator = d3.line()
                        .x(d => xScale(d.absoluteScore) + (d.percentile * 137 % 1 - 0.5) * 8)
                        .y(d => yScale(d.percentile));

                    g.append("path")
                        .datum(sortedData)
                        .attr("class", `year-line year-${year}`)
                        .attr("fill", "none")
                        .attr("stroke", COLORS.yearLine)
                        .attr("stroke-width", 1)
                        .attr("stroke-opacity", 0.3)
                        .attr("d", lineGenerator);
                }
            });

            // Add points with slight horizontal jitter
            g.selectAll(".cutoff-point")
                .data(cutoffData)
                .enter().append("circle")
                .attr("class", d => `cutoff-point year-${d.year}`)
                .attr("cx", d => xScale(d.absoluteScore) + (d.percentile * 137 % 1 - 0.5) * 8)
                .attr("cy", d => yScale(d.percentile))
                .attr("r", 2.5)
                .attr("fill", d => {
                    switch(d.medalType) {
                        case 'Gold': return COLORS.gold;
                        case 'Silver': return COLORS.silver;
                        case 'Bronze': return COLORS.bronze;
                        default: return '#000';
                    }
                })
                .attr("stroke", "#000")
                .attr("stroke-width", 0.5)
                .on("mouseenter", function(event, d) {
                    // Highlight all points and line for this year
                    g.selectAll(`.year-${d.year}`)
                        .classed("highlighted", true);

                    // Make line more prominent
                    g.selectAll(`.year-line.year-${d.year}`)
                        .attr("stroke", COLORS.yearLineHighlight)
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 0.8);

                    // Make points larger
                    g.selectAll(`.cutoff-point.year-${d.year}`)
                        .attr("stroke-width", 2);
                })
                .on("mouseleave", function(event, d) {
                    // Reset all points and line for this year
                    g.selectAll(`.year-${d.year}`)
                        .classed("highlighted", false);

                    // Reset line
                    g.selectAll(`.year-line.year-${d.year}`)
                        .attr("stroke", COLORS.yearLine)
                        .attr("stroke-width", 1)
                        .attr("stroke-opacity", 0.3);

                    // Reset points
                    g.selectAll(`.cutoff-point.year-${d.year}`)
                        .attr("r", 2.5)
                        .attr("stroke-width", 0.5);
                })
                .append("title")
                .text(d => `${d.year} ${d.medalType}: score ${d.absoluteScore}, ${(d.percentile*100).toFixed(1)}% below`);
        }

        // Create scatterplot of problem scores over time
        function createProblemScoresScatterplot(allYearData) {
            const margin = {top: 40, right: 20, bottom: 60, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#problem-scores-scatterplot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Process data for years 1982+ with problem breakdowns
            const problemData = [];
            allYearData.forEach(([year, data]) => {
                if (year >= 1982) {
                    const processedData = processYearData(data);

                    // Filter contestants with complete problem scores
                    const completeScores = processedData.filter(d => {
                        if (d.scores.length === 1) {
                            return false; // Only total score available
                        } else if (d.scores.length === 6) {
                            return true; // Complete problem breakdown
                        } else {
                            console.error(`Unexpected scores length ${d.scores.length} for year ${year}`);
                            return false;
                        }
                    });

                    if (completeScores.length > 0) {
                        // Calculate average score for each problem
                        for (let problem = 1; problem <= 6; problem++) {
                            const problemScores = completeScores.map(d => d.scores[problem - 1]);
                            const averageScore = problemScores.reduce((sum, score) => sum + score, 0) / problemScores.length;

                            problemData.push({
                                year: year,
                                problem: problem,
                                averageScore: averageScore,
                                yearProblem: year + (problem - 1) * 0.15 // Slight offset for visual clarity
                            });
                        }
                    }
                }
            });

            // Set up scales
            const xScale = d3.scaleLinear()
                .domain(d3.extent(problemData, d => d.yearProblem))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 7])
                .range([height, 0]);

            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => Math.floor(d)) // Show years only
                    .ticks(10))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 45)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Year");

            g.append("g")
                .call(d3.axisLeft(yScale).tickValues([0, 1, 2, 3, 4, 5, 6, 7]))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -height / 2)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Average Score");

            // Add grid lines
            const yTicks = [0, 1, 2, 3, 4, 5, 6, 7];
            yTicks.forEach(tick => {
                g.append("line")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", yScale(tick))
                    .attr("y2", yScale(tick))
                    .attr("stroke", COLORS.gridLine)
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("stroke-opacity", 0.5);
            });

            // Add title
            g.append("text")
                .attr("x", width / 2)
                .attr("y", -15)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("IMO Problem Average Scores (1982+)");

            // Create stacked bars based on medal cutoff levels
            const years = [...new Set(problemData.map(d => d.year))].sort((a, b) => a - b);
            const barWidth = width / years.length * 0.9;

            years.forEach(year => {
                const yearProblemData = problemData.filter(d => d.year === year);
                // highest to lowest average score:
                const averageScores = yearProblemData.map(d => d.averageScore);
                averageScores.sort((a, b) => b - a);
                averageScores.unshift(0);

                const cutoffToAverageScore = d3.scaleLinear([0, 7, 14, 21, 28, 35, 42], averageScores);
                //function cutoffToAverageScore(cutoff) {
                //    let problems = Math.ceil(cutoff / 7);
                //    return averageScores[problems];
                //}

                const x = xScale(year);
                const barX = x;

                if (yearProblemData.length > 0) {
                    // Get the stats for medal cutoffs
                    const yearData = allYearData.find(([y, data]) => y === year);
                    if (yearData) {
                        const processedData = processYearData(yearData[1]);
                        const stats = calculateStats(processedData);

                        // Convert cutoffs to average score scale (0-7)
                        const maxPossibleScore = 42; // IMO problems are worth 7 points each, 6 problems
                        const goldLevel = cutoffToAverageScore(stats.goldCutoff);
                        const silverLevel = cutoffToAverageScore(stats.silverCutoff);
                        const bronzeLevel = cutoffToAverageScore(stats.bronzeCutoff);

                        // Create 4 stacked bars - gold on bottom, none on top

                        // Gold bar (bottom) - from gold cutoff level down to 0
                        const goldHeight = yScale(0) - yScale(goldLevel);
                        if (goldHeight > 0) {
                            g.append("rect")
                                .attr("x", barX)
                                .attr("y", yScale(goldLevel))
                                .attr("width", barWidth)
                                .attr("height", goldHeight)
                                .attr("fill", COLORS.gold)
                                .attr("opacity", 0.3);
                        }

                        // Silver bar - from silver level down to gold level
                        const silverHeight = yScale(goldLevel) - yScale(silverLevel);
                        if (silverHeight > 0) {
                            g.append("rect")
                                .attr("x", barX)
                                .attr("y", yScale(silverLevel))
                                .attr("width", barWidth)
                                .attr("height", silverHeight)
                                .attr("fill", COLORS.silver)
                                .attr("opacity", 0.3);
                        }

                        // Bronze bar - from bronze level down to silver level
                        const bronzeHeight = yScale(silverLevel) - yScale(bronzeLevel);
                        if (bronzeHeight > 0) {
                            g.append("rect")
                                .attr("x", barX)
                                .attr("y", yScale(bronzeLevel))
                                .attr("width", barWidth)
                                .attr("height", bronzeHeight)
                                .attr("fill", COLORS.bronze)
                                .attr("opacity", 0.3);
                        }

                        // None bar (top) - from 7 down to bronze level
                        const noneHeight = yScale(bronzeLevel) - yScale(7);
                        if (noneHeight > 0) {
                            g.append("rect")
                                .attr("x", barX)
                                .attr("y", yScale(7))
                                .attr("width", barWidth)
                                .attr("height", noneHeight)
                                .attr("fill", COLORS.none)
                                .attr("opacity", 0.3);
                        }
                    }
                }
            });

            // Color scale for problems
            // questionably subsetting d3's colors to get pairs that are still distinct
            const problemColors = [
                d3.schemeCategory10[0],
                d3.schemeCategory10[1],
                d3.schemeCategory10[3],
                d3.schemeCategory10[2],
                d3.schemeCategory10[8],
                d3.schemeCategory10[4],
            ];

            // Add points for each problem
            g.selectAll(".problem-point")
                .data(problemData)
                .enter().append("circle")
                .attr("class", d => `problem-point problem-${d.problem}`)
                .attr("cx", d => xScale(d.yearProblem))
                .attr("cy", d => yScale(d.averageScore))
                .attr("r", 2.5)
                .attr("fill", d => problemColors[d.problem - 1])
                .attr("stroke", "#000")
                .attr("stroke-width", 0.5)
                .append("title")
                .text(d => `${d.year} Problem ${d.problem}: ${d.averageScore.toFixed(2)} avg`);

            // Add legend
            const legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(20, 20)`);

            for (let i = 0; i < 6; i++) {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(${i * 90}, 0)`);

                legendRow.append("circle")
                    .attr("r", 4)
                    .attr("fill", problemColors[i])
                    .attr("stroke", "#000")
                    .attr("stroke-width", 0.5);

                legendRow.append("text")
                    .attr("x", 10)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .style("font-size", "12px")
                    .text(`Problem ${i+1}`);
            }
        }

        // Create bee swarm plot of problem difficulties
        function createBeeSwarmPlot(allYearData) {
            const margin = {top: 40, right: 20, bottom: 40, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 270 - margin.top - margin.bottom; // 67.5% of original 400px

            const svg = d3.select("#bee-swarm-plot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Process data for years 1982+ with problem breakdowns (same as scatterplot)
            const problemData = [];
            allYearData.forEach(([year, data]) => {
                if (year >= 1982) {
                    const processedData = processYearData(data);
                    const completeScores = processedData.filter(d => {
                        if (d.scores.length === 1) {
                            return false; // Only total score available
                        } else if (d.scores.length === 6) {
                            return true; // Complete problem breakdown
                        } else {
                            console.error(`Unexpected scores length ${d.scores.length} for year ${year}`);
                            return false;
                        }
                    });

                    if (completeScores.length > 0) {
                        // Calculate average score for each problem
                        for (let problem = 1; problem <= 6; problem++) {
                            const problemScores = completeScores.map(d => d.scores[problem - 1]);
                            const averageScore = problemScores.reduce((sum, score) => sum + score, 0) / problemScores.length;

                            problemData.push({
                                year: year,
                                problem: problem,
                                averageScore: averageScore,
                                id: `${year}-P${problem}`
                            });
                        }
                    }
                }
            });

            // Set up scales
            const xScale = d3.scaleLinear()
                .domain([0, 7])
                .range([0, width]);

            // Create bee swarm positions
            const radius = 4;
            const positions = calculateBeeSwarmPositions(problemData, xScale, radius);

            // Create y-scale for upward-only stacking
            const maxY = d3.max(positions, d => d.y);
            const compactHeight = Math.min(height * 0.7, maxY * 1.2); // Use at most 70% of height

            const yScale = d3.scaleLinear()
                .domain([0, maxY])
                .range([height - 5, height - compactHeight - 5]);

            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 35)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Average Score");

            // No y-axis - it's meaningless for a bee swarm plot

            // Add title
            g.append("text")
                .attr("x", width / 2)
                .attr("y", -15)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("IMO Problem Difficulty Distribution (1982+)");

            // Color scale for problems (same as scatterplot)
            const problemColors = [
                d3.schemeCategory10[0],
                d3.schemeCategory10[1],
                d3.schemeCategory10[3],
                d3.schemeCategory10[2],
                d3.schemeCategory10[8],
                d3.schemeCategory10[4],
            ];

            // Add points
            g.selectAll(".bee-point")
                .data(positions)
                .enter().append("circle")
                .attr("class", "bee-point")
                .attr("cx", d => d.x)
                .attr("cy", d => yScale(d.y))
                .attr("r", radius)
                .attr("fill", d => problemColors[d.problem - 1])
                .attr("stroke", d => (d.year === 2025 && (d.problem === 3 || d.problem === 6)) ? "#000" : "#000")
                .attr("stroke-width", d => (d.year === 2025 && (d.problem === 3 || d.problem === 6)) ? 2 : 0.5)
                .append("title")
                .text(d => `${d.year} Problem ${d.problem}: ${d.averageScore.toFixed(2)} avg`);

            // Add annotations for 2025 Problem 3 and Problem 6
            const annotatePoints = positions.filter(d => d.year === 2025 && (d.problem === 3 || d.problem === 6));

            annotatePoints.forEach(d => {
                const pointX = d.x;
                const pointY = yScale(d.y);

                // Position label above the point, but below the legend
                const labelX = pointX;
                const labelY = 50; // Lower position to avoid legend conflict

                // Add annotation line (straight up to bottom of text box)
                g.append("line")
                    .attr("x1", pointX)
                    .attr("y1", pointY - radius)
                    .attr("x2", labelX)
                    .attr("y2", labelY + 4) // Connect to bottom edge of text box
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "2,2");

                // Add label background
                const labelText = `2025 P${d.problem}`;
                const labelWidth = labelText.length * 7; // Approximate width

                g.append("rect")
                    .attr("x", labelX - labelWidth/2 - 5)
                    .attr("y", labelY - 12)
                    .attr("width", labelWidth + 10)
                    .attr("height", 16)
                    .attr("fill", "white")
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1)
                    .attr("rx", 3);

                // Add label text
                g.append("text")
                    .attr("x", labelX)
                    .attr("y", labelY)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#333")
                    .text(labelText);
            });

            // Add legend (same as scatterplot)
            const legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(20, 20)`);

            for (let i = 0; i < 6; i++) {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(${i * 90}, 0)`);

                legendRow.append("circle")
                    .attr("r", 4)
                    .attr("fill", problemColors[i])
                    .attr("stroke", "#000")
                    .attr("stroke-width", 0.5);

                legendRow.append("text")
                    .attr("x", 10)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .style("font-size", "12px")
                    .text(`Problem ${i+1}`);
            }
        }

        // Calculate bee swarm positions to avoid overlap - only stacking upward
        function calculateBeeSwarmPositions(data, xScale, radius) {
            const positions = [];
            const spacing = radius * 2.2; // Spacing between points

            const sortedData = [...data].sort((a, b) => {
                if ((a.problem - 1) % 3 !== (b.problem - 1) % 3) {
                    return (b.problem - 1) % 3 - (a.problem - 1) % 3;
                }
                return a.averageScore - b.averageScore;
            });

            sortedData.forEach(d => {
                const x = xScale(d.averageScore);
                let y = 0;

                // Try to place at y=0 first (on the x-axis)
                if (!hasOverlap(x, y, positions, radius)) {
                    positions.push({...d, x: x, y: y});
                    return;
                }

                // If overlap, try stacking upward only
                for (let level = 1; level <= 40; level++) {
                    const testY = level * 0.5 * spacing;

                    if (!hasOverlap(x, testY, positions, radius)) {
                        positions.push({...d, x: x, y: testY});
                        return;
                    }
                }

                // Fallback: place at a high level
                positions.push({...d, x: x, y: 20 * spacing});
            });

            return positions;
        }

        // Check if a position overlaps with existing points
        function hasOverlap(x, y, positions, radius) {
            const minDistance = radius * 2.2;
            return positions.some(pos => {
                const dx = x - pos.x;
                const dy = y - pos.y;
                return Math.sqrt(dx * dx + dy * dy) < minDistance;
            });
        }

        // Process problem statistics for table
        function processProblemStatistics(allYearData) {
            const problemStats = [];

            allYearData.forEach(([year, data]) => {
                if (year >= 1982) {
                    const processedData = processYearData(data);
                    const completeScores = processedData.filter(d => d.scores.length === 6);

                    if (completeScores.length > 0) {
                        for (let problem = 1; problem <= 6; problem++) {
                            const problemScores = completeScores.map(d => d.scores[problem - 1]);
                            const averageScore = problemScores.reduce((sum, score) => sum + score, 0) / problemScores.length;

                            // Calculate distribution (count of each score 0-7)
                            const distribution = [0, 0, 0, 0, 0, 0, 0, 0]; // indices 0-7
                            problemScores.forEach(score => {
                                if (score >= 0 && score <= 7) {
                                    distribution[score]++;
                                }
                            });

                            problemStats.push({
                                year: year,
                                problem: problem,
                                averageScore: averageScore,
                                distribution: distribution,
                                total: problemScores.length
                            });
                        }
                    }
                }
            });

            return problemStats;
        }

        // Create bar chart for problem score distribution
        function createProblemChart(distribution, total, isStacked = false) {
            const width = isStacked ? 300 : 140;
            const height = isStacked ? 20 : 35;
            const chartHeight = isStacked ? 20 : 20;
            const maxCount = Math.max(...distribution);

            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .style("display", "block");

            if (isStacked) {
                // Stacked horizontal bar
                let x = 0;
                distribution.forEach((count, score) => {
                    if (count > 0) {
                        const segmentWidth = (count / total) * width;
                        const color = d3.interpolateViridis(score / 7);

                        svg.append("rect")
                            .attr("x", x)
                            .attr("y", 0)
                            .attr("width", segmentWidth)
                            .attr("height", chartHeight)
                            .attr("fill", color)
                            .append("title")
                            .text(`Score ${score}: ${count} contestants (${(count/total*100).toFixed(1)}%)`);

                        x += segmentWidth;
                    }
                });
            } else {
                // Regular histogram with gaps and labels
                const barWidth = (width - 14) / 8; // Account for gaps
                const gap = 2;

                distribution.forEach((count, score) => {
                    const barHeight = maxCount > 0 ? (count / maxCount) * chartHeight : 0;
                    const color = d3.interpolateViridis(score / 7);
                    const x = score * (barWidth + gap);

                    svg.append("rect")
                        .attr("x", x)
                        .attr("y", chartHeight - barHeight)
                        .attr("width", barWidth)
                        .attr("height", barHeight)
                        .attr("fill", color)
                        .append("title")
                        .text(`Score ${score}: ${count} contestants`);

                    // Add X-axis labels
                    svg.append("text")
                        .attr("x", x + barWidth / 2)
                        .attr("y", chartHeight + 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", "#666")
                        .text(score);
                });
            }

            return svg.node();
        }

        // Sort problem statistics table
        function sortProblemTable(column, direction = null) {
            if (direction === null) {
                // Toggle direction if same column
                if (currentProblemSort.column === column) {
                    direction = currentProblemSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    direction = column === 'averageScore' ? 'desc' : 'asc';
                }
            }

            currentProblemSort = { column, direction };

            problemStats.sort((a, b) => {
                let aValue = a[column];
                let bValue = b[column];

                // Handle numeric vs string comparison
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return direction === 'asc' ? aValue - bValue : bValue - aValue;
                } else {
                    aValue = String(aValue);
                    bValue = String(bValue);
                    if (direction === 'asc') {
                        return aValue.localeCompare(bValue);
                    } else {
                        return bValue.localeCompare(aValue);
                    }
                }
            });

            renderProblemTable(problemStats, isProblemStackedView);
            updateProblemSortIndicators();
        }

        // Update sort indicators for problem table
        function updateProblemSortIndicators() {
            const table = document.getElementById('problem-stats-table');
            const headers = table.querySelectorAll('.problem-sortable');

            headers.forEach(header => {
                const indicator = header.querySelector('.sort-indicator');
                const column = header.getAttribute('data-column');

                if (column === currentProblemSort.column) {
                    indicator.textContent = currentProblemSort.direction === 'asc' ? '▲' : '▼';
                } else {
                    indicator.textContent = '';
                }
            });
        }

        // Setup problem table sorting
        function setupProblemSorting() {
            const table = document.getElementById('problem-stats-table');
            const sortableHeaders = table.querySelectorAll('.problem-sortable');

            sortableHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.getAttribute('data-column');
                    sortProblemTable(column);
                });
            });
        }

        // Render problem statistics table
        function renderProblemTable(stats, isStacked = false) {
            const tbody = document.getElementById('problem-stats-body');
            tbody.innerHTML = '';

            stats.forEach(stat => {
                const row = document.createElement('tr');

                const yearCell = document.createElement('td');
                yearCell.textContent = stat.year;
                yearCell.className = 'problem-table-narrow';
                row.appendChild(yearCell);

                const problemCell = document.createElement('td');
                problemCell.textContent = stat.problem;
                problemCell.className = 'problem-table-narrow';
                switch ((stat.problem - 1) % 3) {
                    case 0:
                        problemCell.style.backgroundColor = d3.schemePaired[0];
                        break;
                    case 1:
                        problemCell.style.backgroundColor = d3.schemePaired[10];
                        break;
                    case 2:
                        problemCell.style.backgroundColor = d3.schemePaired[4];
                        break;
                }
                row.appendChild(problemCell);

                const avgCell = document.createElement('td');
                avgCell.textContent = stat.averageScore.toFixed(2);
                avgCell.className = 'problem-table-narrow';
                row.appendChild(avgCell);

                const chartCell = document.createElement('td');
                chartCell.className = 'problem-table-chart';
                chartCell.appendChild(createProblemChart(stat.distribution, stat.total, isStacked));
                row.appendChild(chartCell);

                tbody.appendChild(row);
            });
        }

        // Process all years and create table
        function processAllYears(allYearData) {
            // Store data for sorting
            tableData = allYearData.map(([year, data]) => {
                const processedData = processYearData(data);
                const stats = calculateStats(processedData);
                const histogramData = createHistogramData(processedData, year);
                return { year, stats, histogramData };
            });

            // Create scatterplots
            createScatterplot(tableData);
            createProblemScoresScatterplot(allYearData);
            createBeeSwarmPlot(allYearData);

            // Process and render problem statistics table
            problemStats = processProblemStatistics(allYearData);
            sortProblemTable('year', 'desc');

            // Read initial checkbox states
            isStackedView = document.getElementById('stackedToggle').checked;
            isProblemStackedView = document.getElementById('problemStackedToggle').checked;

            // Setup problem table toggle
            document.getElementById('problemStackedToggle').addEventListener('change', function() {
                isProblemStackedView = this.checked;
                renderProblemTable(problemStats, isProblemStackedView);
            });

            sortTable('year', 'desc');
            renderTable();
            setupSorting();
            updateSortIndicators();
            setupProblemSorting();
        }

        function toFixed1Html(f) {
            return f.toFixed(1).replace('.', '<span class="small-percent">.') + "</span>";
        }

        function toPercentHtml(f) {
            return (f * 100).toFixed(1).replace('.', '<span class="small-percent">.') + "%</span>";
        }

        function renderTable() {
            const tbody = document.getElementById('stats-body');
            tbody.innerHTML = '';

            tableData.forEach(({ year, stats, histogramData }) => {
                const row = tbody.insertRow();
                const cellId = `chart-${year}`;

                row.innerHTML = `
                    <td>${year}</td>
                    <td class="stat-cell">${stats.total}</td>
                    <td class="stat-cell bg-gold" title="${stats.gold} gold medals">${toPercentHtml(stats.goldPct)}</td>
                    <td class="stat-cell bg-silver" title="${stats.silver} silver medals">${toPercentHtml(stats.silverPct)}</td>
                    <td class="stat-cell bg-bronze" title="${stats.bronze} bronze medals">${toPercentHtml(stats.bronzePct)}</td>
                    <td class="stat-cell bg-hm${year < 1988 ? ' disabled' : ''}">${year >= 1988 ? toPercentHtml(stats.hmPct) : ''}</td>
                    <td class="stat-cell bg-none">${toPercentHtml(stats.nonePct)}</td>
                    <td class="stat-cell bg-gold">${stats.goldCutoff || '–'}</td>
                    <td class="stat-cell bg-silver">${stats.silverCutoff || '–'}</td>
                    <td class="stat-cell bg-bronze">${stats.bronzeCutoff || '–'}</td>
                    <td class="stat-cell">${toFixed1Html(stats.mean)}</td>
                    <td class="stat-cell">${toFixed1Html(stats.median)}</td>
                    <td class="stat-cell">${stats.mode}</td>
                    <td class="stat-cell">${toFixed1Html(stats.stdDev)}</td>
                    <td class="stat-cell">${stats.min}</td>
                    <td class="stat-cell">${stats.max}</td>
                    <td id="${cellId}" class="chart-cell"></td>
                `;

                if (isStackedView) {
                    createStackedChart(histogramData, cellId, stats, year);
                } else {
                    createMiniChart(histogramData, cellId, stats, year);
                }
            });
        }

        function setupSorting() {
            document.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.column;

                    // Toggle direction if same column, otherwise default to ascending
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.direction = 'asc';
                    }
                    currentSort.column = column;

                    sortTable(column, currentSort.direction);
                    updateSortIndicators();
                });
            });
        }

        function sortTable(column, direction) {
            tableData.sort((a, b) => {
                let aVal, bVal;

                if (column === 'year') {
                    aVal = parseInt(a.year);
                    bVal = parseInt(b.year);
                } else if (column === 'min' || column === 'max') {
                    aVal = a.stats[column];
                    bVal = b.stats[column];
                } else if (column === 'goldCutoff' || column === 'silverCutoff' || column === 'bronzeCutoff') {
                    aVal = a.stats[column] || 999; // Put null values at end
                    bVal = b.stats[column] || 999;
                } else {
                    aVal = parseFloat(a.stats[column]);
                    bVal = parseFloat(b.stats[column]);
                }

                if (direction === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            renderTable();
        }

        function updateSortIndicators() {
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });

            if (currentSort.column) {
                const header = document.querySelector(`[data-column="${currentSort.column}"] .sort-indicator`);
                if (header) {
                    header.textContent = currentSort.direction === 'asc' ? '▲' : '▼';
                }
            }
        }
    </script>
</main>
</body>
</html>
