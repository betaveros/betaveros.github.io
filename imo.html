<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>IMO Score Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; font-variant-numeric: tabular-nums; }
        main { max-width: 1000px; margin: 0 auto; }
        h1 { font-weight: normal; margin: 0; }
        aside { font-size: 12px; display: inline; }
        .stats { margin-bottom: 20px; }
        .bar { fill: steelblue; }
        .bar:hover { fill: orange; }
        .axis { font-size: 10px; }
        .medal-gold { fill: #FFCC00; }
        .medal-silver { fill: #CCCCCC; }
        .medal-bronze { fill: #CC9966; }
        .medal-hm { fill: #FF3399; }
        .medal-none { fill: #99CCFF; }

        table { border-collapse: collapse; width: 100%; }
        th, td { padding: 0 3px; text-align: center; font-size: 12px; }
        th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 10; }
        .compact-col { width: 10px; }
        .loading { text-align: center; padding: 20px; }
        .small-percent { font-size: 8px; }
        .stat-cell { text-align: right; }
        .bg-gold { background-color: #FFCC00; }
        .bg-silver { background-color: #CCCCCC; }
        .bg-bronze { background-color: #CC9966; }
        .bg-hm { background-color: #FF3399; color: white; }
        .bg-hm.disabled { opacity: 0.3; }
        .bg-none { background-color: #99CCFF; }
        .sortable { cursor: pointer; user-select: none; position: relative; }
        .sortable:hover { background-color: #e6e6e6; }
        .sort-indicator {
            position: absolute;
            opacity: 0.5;
            top: 0;
            right: 2px;
            font-size: 8px;
            line-height: 1;
        }
    </style>
</head>
<body>
<main>
    <h1>IMO Statistics <aside>betaveros (with heavy Claude assistance)</aside></h1>

    <div class="loading" id="loading">Loading data...</div>

    <table id="stats-table" style="display: none; margin-top: 10px">
        <thead>
            <tr>
                <th class="compact-col sortable" title="Year" data-column="year">Year<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Number of Contestants" data-column="total">#<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Gold Medal Percentage" data-column="goldPct">G%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Silver Medal Percentage" data-column="silverPct">S%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Bronze Medal Percentage" data-column="bronzePct">B%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Honourable Mention Percentage" data-column="hmPct">HM%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="No Award Percentage" data-column="nonePct">N%<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Gold Medal Cutoff Score" data-column="goldCutoff">G<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Silver Medal Cutoff Score" data-column="silverCutoff">S<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Bronze Medal Cutoff Score" data-column="bronzeCutoff">B<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Mean Score" data-column="mean">μ<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Median Score" data-column="median"><small>Med</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Mode (Most Common Score)" data-column="mode"><small>Mode</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Standard Deviation" data-column="stdDev">σ<span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Minimum Score" data-column="min"><small>Min</small><span class="sort-indicator"></span></th>
                <th class="compact-col sortable" title="Maximum Score" data-column="max"><small>Max</small><span class="sort-indicator"></span></th>
                <th class="chart-cell" title="Score Distribution by Medal Type">Score Distribution</th>
            </tr>
        </thead>
        <tbody id="stats-body">
        </tbody>
    </table>

    <script>
        // Load data from JSON file
        fetch('imo.json')
            .then(response => response.json())
            .then(allYearData => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('stats-table').style.display = 'table';
                processAllYears(allYearData);
            })
            .catch(error => {
                document.getElementById('loading').innerHTML = 'Error loading data: ' + error;
            });

        // Process data for a single year
        function processYearData(data) {
            return data.map(d => ({
                id: d[0],
                scores: d[1],
                total: d[1].reduce((a, b) => a + b, 0),
                medal: d[2] || 'None'
            }));
        }

        // Calculate statistics for a year
        function calculateStats(processedData) {
            const total = processedData.length;
            const scores = processedData.map(d => d.total);

            // Medal counts
            const gold = processedData.filter(d => d.medal === 'Gold medal').length;
            const silver = processedData.filter(d => d.medal === 'Silver medal').length;
            const bronze = processedData.filter(d => d.medal === 'Bronze medal').length;
            const hm = processedData.filter(d => d.medal === 'Honourable mention').length;
            const none = processedData.filter(d => d.medal === 'None' || d.medal === '').length;

            // Medal cutoffs (minimum scores for each medal type)
            const goldScores = processedData.filter(d => d.medal === 'Gold medal').map(d => d.total);
            const silverScores = processedData.filter(d => d.medal === 'Silver medal').map(d => d.total);
            const bronzeScores = processedData.filter(d => d.medal === 'Bronze medal').map(d => d.total);

            const goldCutoff = goldScores.length > 0 ? Math.min(...goldScores) : null;
            const silverCutoff = silverScores.length > 0 ? Math.min(...silverScores) : null;
            const bronzeCutoff = bronzeScores.length > 0 ? Math.min(...bronzeScores) : null;

            // Basic stats
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const sortedScores = [...scores].sort((a, b) => a - b);
            const median = sortedScores.length % 2 === 0
                ? (sortedScores[sortedScores.length/2 - 1] + sortedScores[sortedScores.length/2]) / 2
                : sortedScores[Math.floor(sortedScores.length/2)];

            // Mode (most common score)
            const scoreFreq = {};
            scores.forEach(s => scoreFreq[s] = (scoreFreq[s] || 0) + 1);
            const mode = Object.keys(scoreFreq).reduce((a, b) => scoreFreq[a] > scoreFreq[b] ? a : b);

            // Standard deviation
            const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
            const stdDev = Math.sqrt(variance);

            const min = Math.min(...scores);
            const max = Math.max(...scores);

            return {
                total,
                gold, silver, bronze, hm, none,
                goldPct: (gold/total*100).toFixed(1),
                silverPct: (silver/total*100).toFixed(1),
                bronzePct: (bronze/total*100).toFixed(1),
                hmPct: (hm/total*100).toFixed(1),
                nonePct: (none/total*100).toFixed(1),
                goldCutoff, silverCutoff, bronzeCutoff,
                mean: mean.toFixed(1),
                median: median.toFixed(1),
                mode,
                stdDev: stdDev.toFixed(1),
                min, max
            };
        }

        // Create histogram data for a year
        function createHistogramData(processedData, year) {
            const scoreGroups = d3.group(processedData, d => d.total);
            const histogramData = [];
            const maxScore = getMaxScore(year);

            for (let score = 0; score <= maxScore; score++) {
                const contestants = scoreGroups.get(score) || [];
                const medalGroups = d3.group(contestants, d => d.medal || 'None');

                const medalData = {
                    'Gold medal': medalGroups.get('Gold medal')?.length || 0,
                    'Silver medal': medalGroups.get('Silver medal')?.length || 0,
                    'Bronze medal': medalGroups.get('Bronze medal')?.length || 0,
                    'Honourable mention': medalGroups.get('Honourable mention')?.length || 0,
                    'None': (medalGroups.get('None')?.length || 0) + (medalGroups.get('')?.length || 0)
                };

                histogramData.push({
                    score: score,
                    count: contestants.length,
                    medals: medalData
                });
            }

            return histogramData;
        }

        // Get maximum possible score for a given year
        function getMaxScore(year) {
            if (year >= 1980) return 42;
            if (year === 1971 || year === 1967 || year === 1964) return 42;
            if (year === 1962) return 46;
            if (year === 1960) return 44;
            return 40;
        }

        // Create mini bar chart for table cell
        function createMiniChart(histogramData, cellId, stats, year) {
            const margin = {top: 5, right: 5, bottom: 13, left: 25};
            const width = 480 - margin.left - margin.right;
            const height = 75 - margin.top - margin.bottom;

            const svg = d3.select(`#${cellId}`)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Show full score range for the year (0 to max possible)
            const maxScore = getMaxScore(year);
            const allScores = Array.from({length: maxScore + 1}, (_, i) => i);

            const x = d3.scaleBand()
                .domain(allScores)
                .range([0, width])
                .padding(0.1);

            const maxCount = d3.max(histogramData, d => d.count);
            const y = d3.scaleLinear()
                .domain([0, maxCount])
                .range([height, 0]);

            // Create stacked data
            const medalTypes = ['Gold medal', 'Silver medal', 'Bronze medal', 'Honourable mention', 'None'];
            const stackedData = [];

            histogramData.forEach(d => {
                let y0 = 0;
                medalTypes.forEach(medalType => {
                    const count = d.medals[medalType];
                    if (count > 0) {
                        stackedData.push({
                            score: d.score,
                            medalType: medalType,
                            count: count,
                            y0: y0,
                            y1: y0 + count
                        });
                    }
                    y0 += count;
                });
            });

            // Add dashed vertical lines for cutoffs (behind bars)
            const cutoffData = [
                { score: stats.goldCutoff, color: "#CC9900" },
                { score: stats.silverCutoff, color: "#666666" },
                { score: stats.bronzeCutoff, color: "#996633" }
            ].filter(d => d.score !== null);

            cutoffData.forEach(({ score, color }) => {
                g.append("line")
                    .attr("x1", x(score))
                    .attr("x2", x(score))
                    .attr("y1", -5)
                    .attr("y2", height)
                    .attr("stroke", color)
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "2,2")
                    .style("opacity", 0.7);
            });

            // Create bars
            g.selectAll(".bar")
                .data(stackedData)
                .enter().append("rect")
                .attr("class", d => {
                    switch(d.medalType) {
                        case 'Gold medal': return 'bar medal-gold';
                        case 'Silver medal': return 'bar medal-silver';
                        case 'Bronze medal': return 'bar medal-bronze';
                        case 'Honourable mention': return 'bar medal-hm';
                        default: return 'bar medal-none';
                    }
                })
                .attr("x", d => x(d.score))
                .attr("width", x.bandwidth())
                .attr("y", d => y(d.y1))
                .attr("height", d => y(d.y0) - y(d.y1))
                .append("title")
                .text(d => `Score: ${d.score}\n${d.medalType}: ${d.count}`);

            // Generate standard ticks based on year's max score
            const standardTicks = [];
            for (let i = 0; i <= maxScore; i += 7) {
                standardTicks.push(i);
            }
            if (standardTicks[standardTicks.length - 1] !== maxScore) {
                standardTicks.push(maxScore);
            }

            const cutoffTicks = [stats.goldCutoff, stats.silverCutoff, stats.bronzeCutoff].filter(c => c !== null);
            const allTicks = [...new Set([...standardTicks, ...cutoffTicks])].sort((a, b) => a - b);

            const xAxis = g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).tickValues(allTicks).tickSize(0));

            xAxis.selectAll("text")
                .style("fill", d => {
                    if (d == stats.goldCutoff) return "#CC9900";
                    if (d == stats.silverCutoff) return "#666666";
                    if (d == stats.bronzeCutoff) return "#996633";
                    return "#000000";
                })
                .style("font-weight", d => {
                    if (d == stats.goldCutoff || d == stats.silverCutoff || d == stats.bronzeCutoff) return "bold";
                    return "normal";
                });
        }

        // Global data storage for sorting
        let tableData = [];
        let currentSort = { column: 'year', direction: 'desc' };

        // Process all years and create table
        function processAllYears(allYearData) {
            // Store data for sorting
            tableData = allYearData.map(([year, data]) => {
                const processedData = processYearData(data);
                const stats = calculateStats(processedData);
                const histogramData = createHistogramData(processedData, year);
                return { year, stats, histogramData };
            });

            sortTable('year', 'desc');
            renderTable();
            setupSorting();
            updateSortIndicators();
        }

        function renderTable() {
            const tbody = document.getElementById('stats-body');
            tbody.innerHTML = '';

            tableData.forEach(({ year, stats, histogramData }) => {
                const row = tbody.insertRow();
                const cellId = `chart-${year}`;

                row.innerHTML = `
                    <td>${year}</td>
                    <td class="stat-cell">${stats.total}</td>
                    <td class="stat-cell bg-gold">${stats.goldPct}<span class="small-percent">%</span></td>
                    <td class="stat-cell bg-silver">${stats.silverPct}<span class="small-percent">%</span></td>
                    <td class="stat-cell bg-bronze">${stats.bronzePct}<span class="small-percent">%</span></td>
                    <td class="stat-cell bg-hm${year < 1987 ? ' disabled' : ''}">${year >= 1987 ? stats.hmPct + '<span class="small-percent">%</span>' : ''}</td>
                    <td class="stat-cell bg-none">${stats.nonePct}<span class="small-percent">%</span></td>
                    <td class="stat-cell bg-gold">${stats.goldCutoff || '–'}</td>
                    <td class="stat-cell bg-silver">${stats.silverCutoff || '–'}</td>
                    <td class="stat-cell bg-bronze">${stats.bronzeCutoff || '–'}</td>
                    <td class="stat-cell">${stats.mean}</td>
                    <td class="stat-cell">${stats.median}</td>
                    <td class="stat-cell">${stats.mode}</td>
                    <td class="stat-cell">${stats.stdDev}</td>
                    <td class="stat-cell">${stats.min}</td>
                    <td class="stat-cell">${stats.max}</td>
                    <td id="${cellId}" class="chart-cell"></td>
                `;

                createMiniChart(histogramData, cellId, stats, year);
            });
        }

        function setupSorting() {
            document.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.column;

                    // Toggle direction if same column, otherwise default to ascending
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.direction = 'asc';
                    }
                    currentSort.column = column;

                    sortTable(column, currentSort.direction);
                    updateSortIndicators();
                });
            });
        }

        function sortTable(column, direction) {
            tableData.sort((a, b) => {
                let aVal, bVal;

                if (column === 'year') {
                    aVal = parseInt(a.year);
                    bVal = parseInt(b.year);
                } else if (column === 'min' || column === 'max') {
                    aVal = a.stats[column];
                    bVal = b.stats[column];
                } else if (column === 'goldCutoff' || column === 'silverCutoff' || column === 'bronzeCutoff') {
                    aVal = a.stats[column] || 999; // Put null values at end
                    bVal = b.stats[column] || 999;
                } else {
                    aVal = parseFloat(a.stats[column]);
                    bVal = parseFloat(b.stats[column]);
                }

                if (direction === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            renderTable();
        }

        function updateSortIndicators() {
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });

            if (currentSort.column) {
                const header = document.querySelector(`[data-column="${currentSort.column}"] .sort-indicator`);
                if (header) {
                    header.textContent = currentSort.direction === 'asc' ? '▲' : '▼';
                }
            }
        }
    </script>
</main>
</body>
</html>
